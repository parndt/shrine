<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>multiple_files.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>multiple_files.md
</h1>
<div class='paths'>
doc/multiple_files.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2023-06-02 01:07:30 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>— id: multiple-files</p>

<h2 id="label-title-3A+Multiple+Files">title: Multiple Files<span><a href="#label-title-3A+Multiple+Files">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>import Tabs from ‘@theme/Tabs’; import TabItem from ‘@theme/TabItem’;</p>

<p>There are times when you want to allow users to attach multiple files to a single resource, like an album having many photos or a playlist having many songs. Some file attachment libraries provide a special interface for multiple attachments, but <a href="../../classes/Shrine.html"><code>Shrine</code></a> doesn’t have one, because it’s more flexible to use the “nested attributes” feature of your ORM directly to implement this.</p>

<p>The basic idea is to create a separate table that will have a many-to-one relationship with the main table, and files will be attached on the records in the new table. That way each record from the main table can implicitly have multiple attachments through the associated records.</p>

<pre>album1
  photo1
    - attachment1
  photo2
    - attachment2
  photo3
    - attachment3

album2
  photo4
    - attachment4
  photo5
    - attachment5

...</pre>

<p>To illustrate, this code will create an album with three photos using nested attributes:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(
  <span class="ruby-value">title:</span> <span class="ruby-string">&quot;My Album&quot;</span>,
  <span class="ruby-value">photos_attributes:</span> [
    { <span class="ruby-value">image:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image1.jpg&quot;</span>, <span class="ruby-value">binmode:</span> <span class="ruby-keyword">true</span>) },
    { <span class="ruby-value">image:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image2.jpg&quot;</span>, <span class="ruby-value">binmode:</span> <span class="ruby-keyword">true</span>) },
    { <span class="ruby-value">image:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image3.jpg&quot;</span>, <span class="ruby-value">binmode:</span> <span class="ruby-keyword">true</span>) },
  ]
)
</pre>

<p>This design gives you the greatest flexibility, allowing you to support:</p>
<ul><li>
<p>adding new attachments</p>
</li><li>
<p>updating existing attachments</p>
</li><li>
<p>removing existing attachments</p>
</li><li>
<p>sorting attachments (via a separate position column)</p>
</li><li>
<p>having additional fields on attachments (e.g. captions, votes, number of downloads etc.)</p>
</li><li>
<p>expanding this to be “many-to-many” relation (e.g. create different playlists from a list of songs, etc)</p>
</li><li>
<p>…</p>
</li></ul>

<h2 id="label-How+to+Implement">How to Implement<span><a href="#label-How+to+Implement">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>For the rest of this guide, we will use the example where we have “albums” that can have multiple “photos” in it. The main table is the albums table and the files (or attachments) table will be the photos table.</p>

<h3 id="label-1.+Create+the+main+resource+and+attachment+table">1. Create the main resource and attachment table<span><a href="#label-1.+Create+the+main+resource+and+attachment+table">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Let’s create a table for the main resource and attachments, and add a foreign key in the attachment table for the main table:</p>

<p>&lt;Tabs&gt; &lt;TabItem value=“sequel” label=“Sequel”&gt;</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">change</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">create_table</span> <span class="ruby-value">:albums</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>

      <span class="ruby-constant">String</span> <span class="ruby-value">:title</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">create_table</span> <span class="ruby-value">:photos</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>
      <span class="ruby-identifier">foreign_key</span> <span class="ruby-value">:album_id</span>, <span class="ruby-value">:albums</span>

      <span class="ruby-constant">String</span> <span class="ruby-value">:image_data</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“activerecord” label=“Active Record”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">CreateAlbumsAndPhotos</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Migration</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">change</span>
    <span class="ruby-identifier">create_table</span> <span class="ruby-value">:albums</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">t</span>.<span class="ruby-identifier">string</span>     <span class="ruby-value">:title</span>
      <span class="ruby-identifier">t</span>.<span class="ruby-identifier">timestamps</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">create_table</span> <span class="ruby-value">:photos</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">t</span>.<span class="ruby-identifier">references</span> <span class="ruby-value">:album</span>, <span class="ruby-value">foreign_key:</span> <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">t</span>.<span class="ruby-identifier">text</span>       <span class="ruby-value">:image_data</span>
      <span class="ruby-identifier">t</span>.<span class="ruby-identifier">timestamps</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;/Tabs&gt;</p>

<p>In the Photo model, create a <a href="../../classes/Shrine.html"><code>Shrine</code></a> attachment attribute named <code>image</code> (<code>:image</code> matches the <code>_data</code> column prefix above):</p>

<p>&lt;Tabs&gt; &lt;TabItem value=“sequel” label=“Sequel”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>(<span class="ruby-value">:image</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“activerecord” label=“Active Record”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>(<span class="ruby-value">:image</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;/Tabs&gt;</p>

<h3 id="label-2.+Declare+nested+attributes">2. Declare nested attributes<span><a href="#label-2.+Declare+nested+attributes">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Using nested attributes is the easiest way to implement any dynamic “one-to-many” association. In the Album model we’ll declare a one-to-many relationship to the photos table, and allow it to directly accept attributes for the associated photo records by enabling nested attributes:</p>

<p>&lt;Tabs&gt; &lt;TabItem value=“sequel” label=“Sequel”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-identifier">one_to_many</span> <span class="ruby-value">:photos</span>
  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:association_dependencies</span>, <span class="ruby-value">photos:</span> <span class="ruby-value">:destroy</span> <span class="ruby-comment"># destroy photos when album is destroyed</span>

  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:nested_attributes</span>
  <span class="ruby-identifier">nested_attributes</span> <span class="ruby-value">:photos</span>, <span class="ruby-value">destroy:</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“activerecord” label=“Active Record”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> <span class="ruby-value">:photos</span>, <span class="ruby-value">dependent:</span> <span class="ruby-value">:destroy</span>
  <span class="ruby-identifier">accepts_nested_attributes_for</span> <span class="ruby-value">:photos</span>, <span class="ruby-value">allow_destroy:</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“mongoid” label=“Mongoid”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Mongoid</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>
  <span class="ruby-identifier">embeds_many</span> <span class="ruby-value">:photos</span>
  <span class="ruby-identifier">accepts_nested_attributes_for</span> <span class="ruby-value">:photos</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;/Tabs&gt;</p>

<p>Documentation on nested attributes:</p>
<ul><li>
<p>{<code>Sequel::Model.nested_attributes</code><a target="_top" href="http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/NestedAttributes.html">}</a></p>
</li><li>
<p>{<code>ActiveRecord::Base.accepts_nested_attributes_for</code><a target="_top" href="http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html">}</a></p>
</li><li>
<p>{<code>Mongoid::Document.accepts_nested_attributes_for</code><a target="_top" href="https://docs.mongodb.com/mongoid/master/tutorials/mongoid-nested-attributes/">}</a></p>
</li></ul>

<h3 id="label-3.+Create+the+View">3. Create the View<span><a href="#label-3.+Create+the+View">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Create a form like you normally do to create the album. To this form we’ll add a file field for selecting photos, which will have <code>multiple</code> attribute to allow the user to select multiple files. We’ll also display nested fields for already created photos, so that the same form can be used for updating the album/photos as well (they will be submitted under the <code>album[photos_attributes]</code> parameter).</p>

<p>&lt;Tabs&gt; &lt;TabItem value=“rails” label=“Rails form builder”&gt;</p>

<pre class="ruby"><span class="ruby-identifier">form_for</span> <span class="ruby-ivar">@album</span>, <span class="ruby-value">html:</span> { <span class="ruby-value">enctype:</span> <span class="ruby-string">&quot;multipart/form-data&quot;</span> } <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">text_field</span> <span class="ruby-value">:title</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">fields_for</span> <span class="ruby-value">:photos</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-comment"># adds new `album[photos_attributes]` parameter</span>
    <span class="ruby-identifier">p</span>.<span class="ruby-identifier">hidden_field</span> <span class="ruby-value">:image</span>, <span class="ruby-value">value:</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">object</span>.<span class="ruby-identifier">cached_image_data</span>, <span class="ruby-value">id:</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">p</span>.<span class="ruby-identifier">file_field</span>   <span class="ruby-value">:image</span>
    <span class="ruby-identifier">p</span>.<span class="ruby-identifier">check_box</span>    <span class="ruby-value">:_destroy</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">object</span>.<span class="ruby-identifier">new_record?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">file_field_tag</span> <span class="ruby-string">&quot;files[]&quot;</span>, <span class="ruby-value">multiple:</span> <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">submit</span> <span class="ruby-string">&quot;Create&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“forme” label=“Forme”&gt;</p>

<pre class="ruby"><span class="ruby-identifier">form</span> <span class="ruby-ivar">@album</span>, <span class="ruby-value">action:</span> <span class="ruby-string">&quot;/photos&quot;</span>, <span class="ruby-value">enctype:</span> <span class="ruby-string">&quot;multipart/form-data&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:title</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">subform</span> <span class="ruby-value">:photos</span> <span class="ruby-keyword">do</span> <span class="ruby-comment"># adds new `album[photos_attributes]` parameter</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>,   <span class="ruby-value">type:</span> <span class="ruby-value">:hidden</span>, <span class="ruby-value">value:</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">cached_image_data</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>,   <span class="ruby-value">type:</span> <span class="ruby-value">:file</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:_delete</span>, <span class="ruby-value">type:</span> <span class="ruby-value">:checkbox</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">new?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-string">&quot;files[]&quot;</span>, <span class="ruby-value">type:</span> <span class="ruby-value">:file</span>, <span class="ruby-value">attr:</span> { <span class="ruby-value">multiple:</span> <span class="ruby-keyword">true</span> }, <span class="ruby-value">obj:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span> <span class="ruby-string">&quot;Create&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;/Tabs&gt;</p>

<p>In your controller you should still be able to assign all the attributes to the album, just remember to whitelist the new parameter for the nested attributes, in this case <code>album[photos_attributes]</code>.</p>

<h3 id="label-4a.+Form+upload">4a. Form upload<span><a href="#label-4a.+Form+upload">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you would like to avoid writing JavaScript, you can have selected files uploaded via the form, and then in your controller you can assign them in the format of nested attributes. You’ll want to merge these newly uploaded photos with the existing photos params that will come from the nested form fields. This could look something like this:</p>

<pre class="ruby"><span class="ruby-comment"># In your controller:</span>

<span class="ruby-comment"># transform the list of uploaded files into a photos attributes hash</span>
<span class="ruby-identifier">new_photos_attributes</span> = <span class="ruby-identifier">params</span>[<span class="ruby-value">:files</span>].<span class="ruby-identifier">inject</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">file</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">hash</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-constant">SecureRandom</span>.<span class="ruby-identifier">hex</span> <span class="ruby-operator">=&gt;</span> { <span class="ruby-value">image:</span> <span class="ruby-identifier">file</span> })
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># merge new photos attributes with existing (`album_params` is whitelisted `params[:album]`)</span>
<span class="ruby-identifier">photos_attributes</span> = <span class="ruby-identifier">album_params</span>[<span class="ruby-value">:photos_attributes</span>].<span class="ruby-identifier">to_h</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">new_photos_attributes</span>)
<span class="ruby-identifier">album_attributes</span>  = <span class="ruby-identifier">album_params</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-value">photos_attributes:</span> <span class="ruby-identifier">photos_attributes</span>)

<span class="ruby-comment"># create the album with photos</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">album_attributes</span>)
</pre>

<p>In this case you need to make sure your form tag has <code>enctype=&quot;multipart/form-data&quot;</code> attributes specified, otherwise form upload won’t succeed.</p>

<h3 id="label-4b.+Direct+upload">4b. Direct upload<span><a href="#label-4b.+Direct+upload">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Alternatively, you can have selected files immediately uploaded to a direct upload endpoint, as soon as they’re selected. It’s recommended to use <a target="_top" href="https://uppy.io">Uppy</a> for handling client side file uploads. There are two methods of implementing direct uploads: to your app using the {<code>upload_endpoint</code><a target="_top" href="https://shrinerb.com/docs/plugins/upload_endpoint">}</a> plugin, or directly to a storage like S3 using the {<code>presign_endpoint</code><a target="_top" href="https://shrinerb.com/docs/plugins/presign_endpoint">}</a> plugin. See the walkthroughs for setting up simple <a target="_top" href="https://github.com/shrinerb/shrine/wiki/Adding-Direct-App-Uploads">direct app uploads</a> and <a target="_top" href="https://github.com/shrinerb/shrine/wiki/Adding-Direct-S3-Uploads">direct S3 uploads</a>, as well as the <a target="_top" href="https://github.com/shrinerb/shrine/tree/master/demo">Roda</a> or <a target="_top" href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a> demo app which implement multiple file uploads.</p>

<p>Once files are uploaded asynchronously, you can dynamically insert photo attachment fields for the <code>image</code> attachment attribute into the form, where the hidden field is filled with uploaded file data in JSON format, just like when doing single direct uploads. The attachment field names should be namespaced according to the convention that the nested attributes feature expects. In this case it should be <code>album[photos_attributes][&lt;uid&gt;]</code>, where <code>&lt;uid&gt;</code> is any unique string.</p>

<pre class="ruby"><span class="ruby-comment"># naming format in which photos fields should be generated and submitted</span>
<span class="ruby-identifier">album</span>[<span class="ruby-identifier">photos_attributes</span>][<span class="ruby-value">11111</span>][<span class="ruby-identifier">image</span>] = <span class="ruby-string">&#39;{&quot;id&quot;:&quot;38k25.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>
<span class="ruby-identifier">album</span>[<span class="ruby-identifier">photos_attributes</span>][<span class="ruby-value">29323</span>][<span class="ruby-identifier">image</span>] = <span class="ruby-string">&#39;{&quot;id&quot;:&quot;sg0fg.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>
<span class="ruby-identifier">album</span>[<span class="ruby-identifier">photos_attributes</span>][<span class="ruby-value">34820</span>][<span class="ruby-identifier">image</span>] = <span class="ruby-string">&#39;{&quot;id&quot;:&quot;041jd.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>
</pre>

<p>In your controller you don’t need to make any changes to handle the nested photos attributes (other than allowing them), your ORM will take care of creating, updating, or removing the associated photos.</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">album_params</span>) <span class="ruby-comment"># or `params[:album]`</span>
</pre>

<h3 id="label-5.+Adding+Validations">5. Adding Validations<span><a href="#label-5.+Adding+Validations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can add file validations to the <code>Photo</code> model using the <code>validation_helpers</code> plugin. You just need to make sure that your ORM is configured to automatically validate associated records.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>
  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:validation_helpers</span>
  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:determine_mime_type</span>

  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">10</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>
    <span class="ruby-identifier">validate_mime_type</span> <span class="ruby-node">%w[image/jpeg image/png image/webp]</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;Tabs&gt; &lt;TabItem value=“sequel” label=“Sequel”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>
  <span class="ruby-comment"># ... (nested_attributes already enables validating associated photos) ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;TabItem value=“activerecord” label=“Active Record”&gt;</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Album</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-identifier">validates_associated</span> <span class="ruby-value">:photos</span>
<span class="ruby-keyword">end</span>
</pre>

<p>&lt;/TabItem&gt; &lt;/Tabs&gt;</p>

<p>Note that by default only metadata set on the client side will be available for validations. <a href="../../classes/Shrine.html"><code>Shrine</code></a> will not automatically run metadata extraction for directly uploaded files, as this would require (at least partially) downloading each file from storage, which could be an unwanted performance penalty. If you want metadata to be extracted on the server side, you can load the <code>restore_cached_data</code> plugin which will make metadata extraction run on assignment, or you can extract the metadata manually (e.g. in a background job) using the <code>refresh_metadata</code> plugin.</p>

<h3 id="label-Conclusion">Conclusion<span><a href="#label-Conclusion">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Now we have a simple interface for accepting multiple attachments, which internally uses the nested attributes feature of your ORM to create multiple associated records, each with a single attachment. After creation you can also add new attachments, or update and delete existing ones, which the nested attributes feature gives you for free.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
