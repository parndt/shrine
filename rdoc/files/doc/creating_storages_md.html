<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>creating_storages.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>creating_storages.md
</h1>
<div class='paths'>
doc/creating_storages.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2023-01-04 11:06:42 +0100</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>— id: creating-storages</p>

<h2 id="label-title-3A+Writing+a+Storage">title: Writing a Storage<span><a href="#label-title-3A+Writing+a+Storage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html"><code>Shrine</code></a> ships with the FileSystem and S3 storages, but it’s also easy to create your own. A storage is a class which needs to implement <code>#upload</code>, <code>#url</code>, <code>#open</code>, <code>#exists?</code>, and <code>#delete</code> methods.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>
  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>
    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)
        <span class="ruby-comment"># uploads `io` to the location `id`, can accept upload options</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
        <span class="ruby-comment"># returns the remote file as an IO-like object</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">url</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
        <span class="ruby-comment"># returns URL to the remote file, can accept URL options</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exists?</span>(<span class="ruby-identifier">id</span>)
        <span class="ruby-comment"># returns whether the file exists on storage</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">id</span>)
        <span class="ruby-comment"># deletes the file from the storage</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Upload">Upload<span><a href="#label-Upload">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#upload</code> storage method is called by <code>Shrine#upload</code>, it accepts an IO object (<code>io</code>) and upload location (<code>id</code>) and is expected to upload the IO content to the specified location. It’s also given <code>:shrine_metadata</code> that was extracted from the IO, which can be used for specifying request headers on upload. The storage can also support custom upload options (which can be utilized with the <code>upload_options</code> plugin).</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)
    <span class="ruby-comment"># uploads `io` to the location `id`, can accept upload options</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Unless you’re already using a Ruby SDK, it’s recommended to use <a target="_top" href="https://github.com/httprb/http">HTTP.rb</a> for uploading. It accepts any IO object that implements <code>IO#read</code> (not just file objects), and it streams the request body directly to the TCP socket, both for raw and multipart uploads, making it suitable for large uploads.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;http&quot;</span>

<span class="ruby-comment"># streaming raw upload</span>
<span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post</span>(<span class="ruby-string">&quot;http://example.com/upload&quot;</span>, <span class="ruby-value">body:</span> <span class="ruby-identifier">io</span>)
<span class="ruby-comment"># streaming multipart upload</span>
<span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post</span>(<span class="ruby-string">&quot;http://example.com/upload&quot;</span>, <span class="ruby-value">form:</span> { <span class="ruby-value">file:</span> <span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">FormData</span><span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>) })
</pre>

<p>It’s good practice to test the storage with a <a target="_top" href="https://github.com/shrinerb/shrine/blob/master/test/support/fakeio.rb">fake IO</a> object which responds only to required methods, as not all received IO objects will be file objects.</p>

<p>If your storage doesn’t control which id the uploaded file will have, you can modify the <code>id</code> variable before returning:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)
  <span class="ruby-comment"># ...</span>
  <span class="ruby-identifier">id</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">actual_id</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Likewise, if you need to save some information into the metadata after upload (e.g. if the MIME type of the file changes on upload), you can modify the metadata hash:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)
  <span class="ruby-comment"># ...</span>
  <span class="ruby-identifier">shrine_metadata</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">returned_metadata</span>)
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Open">Open<span><a href="#label-Open">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#open</code> storage method is called by various <code>Shrine::UploadedFile</code> methods that retrieve uploaded file content. It accepts the file location and is expected to return an IO-like object (that implements <code>#read</code>, <code>#size</code>, <code>#rewind</code>, <code>#eof?</code>, and <code>#close</code>) that represents the uploaded file.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># returns the remote file as an IO-like object</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Ideally, the returned IO object should lazily retrieve uploaded content, so that in cases where metadata needs to be extracted from an uploaded file, only a small portion of the file will be downloaded.</p>

<p>It’s recommended to use the <a target="_top" href="https://github.com/janko/down">Down</a> gem for this. If the storage exposes its files over HTTP, you can use <code>Down.open</code>, otherwise if it’s possible to stream chunks of content from the storage, that can be wrapped in a <code>Down::ChunkedIO</code>. It’s recommended to use the {<code>Down::Http</code><a target="_top" href="https://github.com/janko/down#httprb">}</a> backend, as the <a target="_top" href="https://github.com/httprb/http">HTTP.rb</a> gem allocates an order of magnitude less memory when reading the response body compared to <code>Net::HTTP</code>.</p>

<p>The storage can support additional options to customize how the file will be opened, <code>Shrine::UploadedFile#open</code> and <code>Shrine::UploadedFile#download</code> will forward any given options to <code>#open</code>.</p>

<p>When file is not found, <code>Shrine::FileNotFound</code> exception should be raised.</p>

<h2 id="label-Url">Url<span><a href="#label-Url">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#url</code> storage method is called by <code>Shrine::UploadedFile#url</code>, it accepts a file location and is expected to return a resolvable URL to the uploaded file. Custom URL options can be supported if needed, <code>Shrine::UploadedFile#url</code> will forward any given options to <code>#url</code>.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">url</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># returns URL to the remote file, can accept URL options</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>If the storage does not have uploaded files accessible via HTTP, the <code>#url</code> method should return <code>nil</code>. Note that in this case users can use the <code>download_endpoint</code> or <code>rack_response</code> plugins to create a downloadable link, which are implemented in terms of <code>#open</code>.</p>

<h2 id="label-Exists">Exists<span><a href="#label-Exists">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#exists?</code> storage method is called by <code>Shrine::UploadedFile#exists?</code>, it accepts a file location and should return <code>true</code> if the file exists on the storage and <code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exists?</span>(<span class="ruby-identifier">id</span>)
    <span class="ruby-comment"># returns whether the file exists on storage</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Delete">Delete<span><a href="#label-Delete">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#delete</code> storage method is called by <code>Shrine::UploadedFile#delete</code>, it accepts a file location and is expected to delete the file from the storage.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">id</span>)
    <span class="ruby-comment"># deletes the file from the storage</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>For convenience of use, this method should not raise an exception if the file doesn’t exist.</p>

<h2 id="label-Presign">Presign<span><a href="#label-Presign">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If the storage service supports direct uploads, and requires fetching additional information from the server, you can implement a <code>#presign</code> method, which will be called by the <code>presign_endpoint</code> plugin. The <code>#presign</code> method should return a Hash with the following keys:</p>
<ul><li>
<p><code>:method</code> – HTTP verb that should be used</p>
</li><li>
<p><code>:url</code> – URL to which the file should be uploaded to</p>
</li><li>
<p><code>:fields</code> – Hash of request parameters that should be used for the upload (optional)</p>
</li><li>
<p><code>:headers</code> – Hash of request headers that should be used for the upload (optional)</p>
</li></ul>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">presign</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># returns a Hash with :method, :url, :fields, and :headers keys</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The storage can support additional options to customize how the presign will be generated, those can be forwarded via the <code>:presign_options</code> option on the <code>presign_endpoint</code> plugin.</p>

<h2 id="label-Delete+Prefixed+and+Clear">Delete Prefixed and Clear<span><a href="#label-Delete+Prefixed+and+Clear">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are two methods that are not currently used by shrine, but which it’s good for storages to provide to allow client code to delete files from storage. If storages provide these conventional methods, then clients can delete files using consistent API for any storage.</p>

<p><code>#clear!</code> deletes all files from storage, and <code>#delete_prefixed</code> will delete all files in a given directory/prefix/path. While not strictly required for shrine storage service functionality, storages should usually implement if possible.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_prefixed</span>(<span class="ruby-identifier">prefix_path</span>)
    <span class="ruby-comment"># deletes all files under the supplied argument prefix</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear!</span>
    <span class="ruby-comment"># deletes all files in the storage</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Update">Update<span><a href="#label-Update">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If your storage supports updating data of existing files (e.g. some metadata), the convention is to create an <code>#update</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>
  <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)
    <span class="ruby-comment"># update data of the file</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Linter">Linter<span><a href="#label-Linter">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To check that your storage implements all these methods correctly, you can use <code>Shrine::Storage::Linter</code>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/linter&quot;</span>

<span class="ruby-identifier">storage</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">MyStorage</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-identifier">linter</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Linter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">storage</span>)
<span class="ruby-identifier">linter</span>.<span class="ruby-identifier">call</span>
</pre>

<p>The linter will test your methods with fake IO objects, and raise a <code>Shrine::LintError</code> if any part of the contract isn’t satisfied.</p>

<p>If you want to specify the IO object to use for testing (e.g. you need the IO to be an actual image), you can pass in a lambda which returns the IO when called:</p>

<pre class="ruby"><span class="ruby-identifier">linter</span>.<span class="ruby-identifier">call</span>(<span class="ruby-operator">-&gt;</span>{<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;test/fixtures/image.jpg&quot;</span>)})
</pre>

<p>If you don’t want errors to be raised but rather only warnings, you can pass <code>action: :warn</code> when initializing</p>

<pre class="ruby"><span class="ruby-identifier">linter</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Linter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">storage</span>, <span class="ruby-value">action:</span> <span class="ruby-value">:warn</span>)
</pre>

<p>Note that using the linter doesn’t mean that you shouldn’t write any manual tests for your storage. There will likely be some edge cases that won’t be tested by the linter.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
