"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7445],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=r,h=d["".concat(p,".").concat(u)]||d[u]||c[u]||i;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={title:"Shrine 2.10.0"},p=void 0,s={unversionedId:"release_notes/2.10.0",id:"release_notes/2.10.0",title:"Shrine 2.10.0",description:"New features",source:"@site/../doc/release_notes/2.10.0.md",sourceDirName:"release_notes",slug:"/release_notes/2.10.0",permalink:"/docs/release_notes/2.10.0",draft:!1,editUrl:"https://github.com/shrinerb/shrine/edit/master/doc/../doc/release_notes/2.10.0.md",tags:[],version:"current",lastUpdatedBy:"Janko Marohni\u0107",lastUpdatedAt:1571049580,formattedLastUpdatedAt:"Oct 14, 2019",frontMatter:{title:"Shrine 2.10.0"},sidebar:"release_notes",previous:{title:"Shrine 2.10.1",permalink:"/docs/release_notes/2.10.1"},next:{title:"Shrine 2.9.0",permalink:"/docs/release_notes/2.9.0"}},m={},d=[{value:"New features",id:"new-features",level:2},{value:"Other improvements",id:"other-improvements",level:2},{value:"Backwards compatibility",id:"backwards-compatibility",level:2}],c={toc:d},u="wrapper";function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"new-features"},"New features"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},":mini_magick")," analyzer has been added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"store_dimensions")," plugin,\nwhich uses the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/minimagick/minimagick"},"MiniMagick")," gem to extract image dimensions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},":ruby_vips")," analyzer has been added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"store_dimensions")," plugin,\nwhich uses the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/libvips/ruby-vips"},"ruby-vips")," gem to extract image dimensions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},":fastimage")," analyzer has been added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"determine_mime_type")," plugin,\nwhich uses the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sdsykes/fastimage"},"FastImage")," gem to determine the MIME type of the file.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Shrine::UploadedFile#download")," now accepts a block for downloading an\nuploaded file temporarily. This is useful when wanting to validate whether an\nuploaded image is valid or corrupted, or when generating thumbnails."))),(0,i.kt)("div",{"data-rehype-pretty-code-fragment":""},(0,i.kt)("pre",{parentName:"div","data-language":"rb","data-theme":"default"},(0,i.kt)("code",{parentName:"pre","data-language":"rb","data-theme":"default"},(0,i.kt)("span",{parentName:"code",className:"line"},(0,i.kt)("span",{parentName:"span",style:{color:"#F6F6F4"}},"uploaded_file.download "),(0,i.kt)("span",{parentName:"span",style:{color:"#F286C4"}},"do"),(0,i.kt)("span",{parentName:"span",style:{color:"#F6F6F4"}}," |tempfile|")),"\n",(0,i.kt)("span",{parentName:"code",className:"line"},(0,i.kt)("span",{parentName:"span",style:{color:"#F6F6F4"}},"  "),(0,i.kt)("span",{parentName:"span",style:{color:"#7B7F8B"}},"# ...")),"\n",(0,i.kt)("span",{parentName:"code",className:"line"},(0,i.kt)("span",{parentName:"span",style:{color:"#F286C4"}},"end"),(0,i.kt)("span",{parentName:"span",style:{color:"#F6F6F4"}}," "),(0,i.kt)("span",{parentName:"span",style:{color:"#7B7F8B"}},"# tempfile is deleted"))))),(0,i.kt)("h2",{id:"other-improvements"},"Other improvements"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It's not required that IO objects respond to ",(0,i.kt)("inlineCode",{parentName:"p"},"#size")," anymore. This is\nuseful when uploading streams of data where the size is not known.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The S3 storage now supports IO objects with unknown size. Under the hood it\nwill use multipart upload.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The logger is now properly inherited and shared between ",(0,i.kt)("inlineCode",{parentName:"p"},"Shrine")," subclasses.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The attachment URL generated by ",(0,i.kt)("inlineCode",{parentName:"p"},"download_endpoint")," now stays the same\nregardless of the order of elements in the metadata hash. Previously it could\nchange after the uploaded file data is loaded from the database, because the\norder of the metadata hash elements would change, which is not desirable for\ncaching."))),(0,i.kt)("h2",{id:"backwards-compatibility"},"Backwards compatibility"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},":rack_mime")," extension inferrer has been removed from the\n",(0,i.kt)("inlineCode",{parentName:"p"},"infer_extension")," plugin, due to not having acceptable behaviour. The new\ndefault extension inferrer is ",(0,i.kt)("inlineCode",{parentName:"p"},":mime_types"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},":heroku")," formatter in the ",(0,i.kt)("inlineCode",{parentName:"p"},"logging")," plugin has been soft-renamed to\n",(0,i.kt)("inlineCode",{parentName:"p"},":logfmt"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},":heroku")," alias will stop being supported in Shrine 3.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Shrine::IO_METHODS")," constant has been depreacted, and will become\nprivate in Shrine 3."))))}h.isMDXComponent=!0}}]);